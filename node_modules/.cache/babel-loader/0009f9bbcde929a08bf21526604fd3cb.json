{"ast":null,"code":"var _jsxFileName = \"/Users/seojiwon/Desktop/\\uB370\\uC2A4\\uD06C\\uD0D1 - zwon - 1/ReactProgramming_Doit/src/03/Counter.jsx\",\n    _s = $RefreshSig$();\n\n// 리액트 16.8 이전 버전에서는 함수형 컴포넌트에서는 상태를 관리할 수 없었다.\n// 리액트 16.8 에서 Hooks 라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었다.\n// 이번에는 useState 라는 함수를 사용해보게 되는데, 이게 바로 리액트의 Hooks 중 하나이다.\nimport { useState } from 'react';\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Counter() {\n  _s();\n\n  const [number, setNumber] = useState(0);\n\n  const increase = () => {\n    console.log(\"number = \", number); // setNumber(number - 1);\n\n    setNumber(prevNumber => prevNumber + 1); // 지금은 Setter 함수를 사용 할 때, 업데이트 하고 싶은 새로운 값을 파라미터로 넣어주고 있는데,\n    // 그 대신에 기존 값을 어떻게 업데이트 할 지에 대한 함수를 등록하는 방식으로도 값을 업데이트 할 수 있다.\n\n    console.log(\"number = \", number);\n  };\n\n  const decrease = () => {\n    console.log(\"number = \", number);\n    setNumber(number - 1);\n    console.log(\"number = \", number);\n  };\n\n  const [count, setCount] = useState(0);\n\n  const onClick1 = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n    console.dir(count);\n  };\n\n  const onClick2 = () => {\n    setCount(count => count + 1);\n    setCount(count => count + 1); // 아래의 setCount 함수에 넘겨진 인자의 왼쪽 count가 이전의 count 값임을 보장할 수 있다.\n\n    console.dir(count);\n  }; // 이렇게 함수형으로 파라미터를 넘겨주면 상태값 변경을 \"배치\"로 처리한다고 하네요.\n  // count+ 1 (값을 넣는 경우) 랑 count=> count+ 1 (함수를 넣는 경우) 랑 뭐가 다르나? \n  // 둘이 별 차이가 없을 것 같지만 (useState에서 받는 state 값도 이전의 값일 것이기 때문에) \n  // 전혀 그렇지 않다. \n  // state가 여럿일 경우에 다른 state의 변화로 리렌더링이 거의 동시에 이루어지거나 하게 되면\n  // useState 왼쪽의 state가 이전의 값임을 보장할 수 없을 때가 있다.\n  // 이는 state의 변화가 비동기적(async)으로 일어나기 때문이다.\n  // setState가 호출되면 바로 state가 바뀌는 게 아니라\n  // 리액트에게 변경해야할 state를 알려주는 것이고\n  // 리액트는 다른 state의 변경 요청까지를 다 받은 다음\n  // 한 번에 묶어서 state를 변경하여 리렌더링시킨다.\n  // (promise나 setTimeout 등을 제외하고 그 안에 실행된 모든 state들을 하나로 묶는다.)\n  // 때문에 1을 더하는 것과 같이 state의 업데이트가 이전의 값에 의존하는 경우\n  // 반드시 setState 함수의 인자에 함수를 넣어야 한다.\n  // 그래야만 함수에서 받는 인자(count)가 이전의 값임을 장담할 수 있다.\n  // 이전의 값에 의존할 필요가 없는 경우에는 쓸데없이 코드가 길어지니 불필요하다.\n  // setState()는 비동기식이며 동일한 주기 동안 여러 호출을 일괄 처리할 수 있습니다. (배치)\n  // 예를 들어 동일한 주기에서 항목 수량을 두 번 이상 늘리려고 하면 setState() 호출을 여러 번 하게 되는데\n  // 후속 호출은 동일한 주기의 이전 호출 값을 무시하므로 수량은 한 번만 증가합니다.\n  // 다음 상태가 현재 상태에 따라 달라지는 경우 대신 업데이트 함수 형식을 사용하는 것이 좋습니다.\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: number\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 68,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: increase,\n      children: \"+1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 69,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: decrease,\n      children: \"-1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: count\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: onClick1,\n      children: \" count + 1 \\uBC84\\uD2BC \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 72,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: onClick2,\n      children: \" count = count + 1 \\uBC84\\uD2BC \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 73,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 67,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Counter, \"KuX9etCVXzvI4HoTbSwTXjsW+YM=\");\n\n_c = Counter;\nexport default Counter;\n\nvar _c;\n\n$RefreshReg$(_c, \"Counter\");","map":{"version":3,"sources":["/Users/seojiwon/Desktop/데스크탑 - zwon - 1/ReactProgramming_Doit/src/03/Counter.jsx"],"names":["useState","React","Counter","number","setNumber","increase","console","log","prevNumber","decrease","count","setCount","onClick1","dir","onClick2"],"mappings":";;;AAAA;AACA;AACA;AAGA,SAASA,QAAT,QAAyB,OAAzB;AACA,OAAOC,KAAP,MAAkB,OAAlB;;;AAEA,SAASC,OAAT,GAAmB;AAAA;;AACf,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBJ,QAAQ,CAAC,CAAD,CAApC;;AAEA,QAAMK,QAAQ,GAAG,MAAO;AACpBC,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBJ,MAAzB,EADoB,CAEpB;;AACAC,IAAAA,SAAS,CAACI,UAAU,IAAIA,UAAU,GAAG,CAA5B,CAAT,CAHoB,CAIpB;AACA;;AACAF,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBJ,MAAzB;AACH,GAPD;;AASA,QAAMM,QAAQ,GAAG,MAAM;AACnBH,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBJ,MAAzB;AACAC,IAAAA,SAAS,CAACD,MAAM,GAAG,CAAV,CAAT;AACAG,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBJ,MAAzB;AACH,GAJD;;AAMA,QAAM,CAACO,KAAD,EAAQC,QAAR,IAAoBX,QAAQ,CAAC,CAAD,CAAlC;;AAEA,QAAMY,QAAQ,GAAG,MAAM;AACnBD,IAAAA,QAAQ,CAACD,KAAK,GAAE,CAAR,CAAR;AACAC,IAAAA,QAAQ,CAACD,KAAK,GAAE,CAAR,CAAR;AACAJ,IAAAA,OAAO,CAACO,GAAR,CAAYH,KAAZ;AACH,GAJD;;AAMA,QAAMI,QAAQ,GAAG,MAAM;AACnBH,IAAAA,QAAQ,CAACD,KAAK,IAAGA,KAAK,GAAE,CAAhB,CAAR;AACAC,IAAAA,QAAQ,CAACD,KAAK,IAAGA,KAAK,GAAE,CAAhB,CAAR,CAFmB,CAGnB;;AACAJ,IAAAA,OAAO,CAACO,GAAR,CAAYH,KAAZ;AACH,GALD,CA1Be,CAiCf;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAEA,sBACI;AAAA,4BACI;AAAA,gBAAKP;AAAL;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI;AAAQ,MAAA,OAAO,EAAEE,QAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFJ,eAGI;AAAQ,MAAA,OAAO,EAAEI,QAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAHJ,eAII;AAAA,gBAAKC;AAAL;AAAA;AAAA;AAAA;AAAA,YAJJ,eAKI;AAAQ,MAAA,OAAO,EAAEE,QAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YALJ,eAMI;AAAQ,MAAA,OAAO,EAAEE,QAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YANJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAUH;;GAnEQZ,O;;KAAAA,O;AAqET,eAAeA,OAAf","sourcesContent":["// 리액트 16.8 이전 버전에서는 함수형 컴포넌트에서는 상태를 관리할 수 없었다.\n// 리액트 16.8 에서 Hooks 라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었다.\n// 이번에는 useState 라는 함수를 사용해보게 되는데, 이게 바로 리액트의 Hooks 중 하나이다.\n\n\nimport { useState } from 'react';\nimport React from 'react';\n\nfunction Counter() {\n    const [number, setNumber] = useState(0);\n\n    const increase = () =>  {\n        console.log(\"number = \", number);\n        // setNumber(number - 1);\n        setNumber(prevNumber => prevNumber + 1);\n        // 지금은 Setter 함수를 사용 할 때, 업데이트 하고 싶은 새로운 값을 파라미터로 넣어주고 있는데,\n        // 그 대신에 기존 값을 어떻게 업데이트 할 지에 대한 함수를 등록하는 방식으로도 값을 업데이트 할 수 있다.\n        console.log(\"number = \", number);\n    }\n\n    const decrease = () => {\n        console.log(\"number = \", number);\n        setNumber(number - 1);\n        console.log(\"number = \", number);\n    }\n\n    const [count, setCount] = useState(0);\n\n    const onClick1 = () => {\n        setCount(count+ 1);\n        setCount(count+ 1);\n        console.dir(count);\n    }\n\n    const onClick2 = () => {\n        setCount(count=> count+ 1);\n        setCount(count=> count+ 1);\n        // 아래의 setCount 함수에 넘겨진 인자의 왼쪽 count가 이전의 count 값임을 보장할 수 있다.\n        console.dir(count);\n    }\n\n    // 이렇게 함수형으로 파라미터를 넘겨주면 상태값 변경을 \"배치\"로 처리한다고 하네요.\n\n    // count+ 1 (값을 넣는 경우) 랑 count=> count+ 1 (함수를 넣는 경우) 랑 뭐가 다르나? \n\n    // 둘이 별 차이가 없을 것 같지만 (useState에서 받는 state 값도 이전의 값일 것이기 때문에) \n    // 전혀 그렇지 않다. \n    // state가 여럿일 경우에 다른 state의 변화로 리렌더링이 거의 동시에 이루어지거나 하게 되면\n    // useState 왼쪽의 state가 이전의 값임을 보장할 수 없을 때가 있다.\n    // 이는 state의 변화가 비동기적(async)으로 일어나기 때문이다.\n    // setState가 호출되면 바로 state가 바뀌는 게 아니라\n    // 리액트에게 변경해야할 state를 알려주는 것이고\n    // 리액트는 다른 state의 변경 요청까지를 다 받은 다음\n    // 한 번에 묶어서 state를 변경하여 리렌더링시킨다.\n    // (promise나 setTimeout 등을 제외하고 그 안에 실행된 모든 state들을 하나로 묶는다.)\n    // 때문에 1을 더하는 것과 같이 state의 업데이트가 이전의 값에 의존하는 경우\n    // 반드시 setState 함수의 인자에 함수를 넣어야 한다.\n    // 그래야만 함수에서 받는 인자(count)가 이전의 값임을 장담할 수 있다.\n    // 이전의 값에 의존할 필요가 없는 경우에는 쓸데없이 코드가 길어지니 불필요하다.\n\n    // setState()는 비동기식이며 동일한 주기 동안 여러 호출을 일괄 처리할 수 있습니다. (배치)\n    // 예를 들어 동일한 주기에서 항목 수량을 두 번 이상 늘리려고 하면 setState() 호출을 여러 번 하게 되는데\n    // 후속 호출은 동일한 주기의 이전 호출 값을 무시하므로 수량은 한 번만 증가합니다.\n    // 다음 상태가 현재 상태에 따라 달라지는 경우 대신 업데이트 함수 형식을 사용하는 것이 좋습니다.\n\n    return (\n        <div>\n            <h1>{number}</h1>\n            <button onClick={increase}>+1</button>\n            <button onClick={decrease}>-1</button>\n            <h1>{count}</h1>\n            <button onClick={onClick1}> count + 1 버튼 </button>\n            <button onClick={onClick2}> count = count + 1 버튼 </button>\n        </div>\n    );\n}\n\nexport default Counter;"]},"metadata":{},"sourceType":"module"}